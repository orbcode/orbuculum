/* SPDX-License-Identifier: BSD-3-Clause */

/*
 * COBS Encoder/Decoder Module
 * ===========================
 *
 * Routines based on code from http://www.stuartcheshire.org/papers/COBSforToN.pdf
 *
 */

#include <string.h>
#include <stdlib.h>
#include "cobs.h"

#define COBS_SYNC_CHAR (0)

const uint8_t cobs_eop[COBS_EOP_LEN] = { COBS_SYNC_CHAR };

// ====================================================================================================
struct COBS *COBSInit( struct COBS *t )

/* Reset a COBS instance */

{
    if ( !t )
    {
        t = ( struct COBS * )calloc( 1, sizeof( struct COBS ) );
        t->selfAllocated = true;
    }

    return t;
}
// ====================================================================================================
void COBSDelete( struct COBS *t )

/* Destroy a COBS instance, but only if we created it */

{
    if ( t->selfAllocated )
    {
        free( t );
        t = NULL;
    }
}

// ====================================================================================================

void COBSEncode( const uint8_t *inputMsg, int len, struct Frame *o )

/* Encode frame and write into provided output Frame buffer */

{
    uint8_t *wp = o->d;
    o->len = 0;

    /* We always start a frame with a sync so the receivers got a chance */
    *wp++ = COBS_SYNC_CHAR;

    if ( len )
    {
        uint8_t *cp = wp++;
        int seglen = 1;

        for ( const uint8_t *rp = inputMsg; len--; rp++ )
        {
            if ( COBS_SYNC_CHAR != *rp )
            {
                *wp++ = *rp;
                seglen++;
            }

            if ( ( COBS_SYNC_CHAR == *rp ) || ( 0xff == seglen ) )
            {
                *cp = seglen;
                seglen = 1;
                cp = wp;

                if ( ( COBS_SYNC_CHAR == *rp )  || len )
                {
                    wp++;
                }
            }
        }

        *cp = seglen;
    }


    o->len = ( wp - o->d );
}

// ====================================================================================================

bool COBSisEOFRAME( const uint8_t *inputEnc )

{
    return ( COBS_SYNC_CHAR == *inputEnc );
}

// ====================================================================================================

void COBSPump( struct COBS *t, uint8_t *incoming, int len,
               void ( *packetRxed )( struct Frame *p, void *param ),
               void *param )


/* Assemble this packet into a complete frame and call back */

{
    uint8_t *fp = incoming;

    for ( unsigned int rlen = 0; rlen < len; rlen++, fp++ )
    {
        switch ( t->s )
        {
            case COBS_IDLE:  // -------------------------------------------------------------------
                if ( COBS_SYNC_CHAR != *fp )
                {
                    t->f.len = 0;
                    t->intervalCount = *fp;
                    t->maxCount = ( *fp == 255 );
                    t->s = COBS_RXING;
                }

                break;

            case COBS_RXING: // -------------------------------------------------------------------
                t->intervalCount--;

                if ( !t->intervalCount )
                {
                    if ( COBS_SYNC_CHAR == *fp )
                    {
                        /* This is the end of a packet */
                        packetRxed( &t->f, param );
                        t->s = COBS_IDLE;
                    }
                    else
                    {
                        if ( !t->maxCount )
                        {
                            t->f.d[t->f.len++] = COBS_SYNC_CHAR;
                        }

                        t->intervalCount = *fp;
                        t->maxCount = ( *fp == 255 );
                    }
                }
                else
                {
                    if ( COBS_SYNC_CHAR == *fp )
                    {
                        /* This is the end of a packet and the lengths don't match */
                        t->error++;
                        t->s = COBS_IDLE;
                    }
                    else
                    {
                        t->f.d[t->f.len++] = *fp;
                    }
                }

                /* Check for frame overflow ... if it's max then error */
                if ( COBS_MAX_PACKET_LEN == t->f.len )
                {
                    t->error++;
                    t->s = COBS_IDLE;
                }

                break;
        }
    }
}

// ====================================================================================================
const uint8_t *COBSSimpleDecode( const uint8_t *inputEnc, int len, struct Frame *o )

/* Decode frame and write decoded frame into provided Frame buffer           */
/* Returns pointer to first character after frame (should be COBS_SYNC_CHAR) */
/* or NULL if packet did not decode...and store the fragment.                */

{
    const uint8_t *fp = inputEnc;
    const uint8_t *efp = inputEnc + len;

    uint8_t *op = o->d;

    int interval;

    /* Deal with possibility of sync chars on the front */
    while  ( ( COBS_SYNC_CHAR == *fp ) && ( fp < efp ) )
    {
        fp++;
    }

    while ( fp < efp )
    {
        interval = *fp++;

        if ( COBS_SYNC_CHAR == interval )
        {
            /* We have finished...for better or worse */
            break;
        }

        for ( int i = 1; i < interval; i++ )
        {
            /* Deal with possibility of illegal sync chars in the flow */
            if ( *fp == COBS_SYNC_CHAR )
            {
                break;
            }

            *op++ = *fp++;
        }

        if ( interval < 0xff )
        {
            *op++ = COBS_SYNC_CHAR;
        }
    }

    //    if ( ( COBSisEOFRAME( fp ) ) && ( op - o->d ) )
    if ( op - o->d )
    {
        o->len = op - o->d;
        return fp;
    }

    return NULL;
}

// ====================================================================================================

const uint8_t *COBSgetFrameExtent( const uint8_t *inputEnc, int len )

/* Look through memory until an end of frame marker is found, or memory is exhausted. */

{
    /* Go find the next sync */
    while ( !COBSisEOFRAME( inputEnc ) && --len )
    {
        inputEnc++;
    }

    return inputEnc;
}

// ====================================================================================================
// ====================================================================================================
// ====================================================================================================
// Test Cases
// ====================================================================================================
// ====================================================================================================
// ====================================================================================================

/* Build tests with;
 * gcc -DTESTING_COBS cobs.c -I ../Inc -ggdb
 * Execute with;
 * ./a.out
 */

#ifdef TESTING_COBS

#include <stdio.h>

static void _printDigits( int length, uint8_t *d )
{
    while ( length-- )
    {
        fprintf( stderr, "%02x ", *d++ );
    }
}


struct test
{
    struct Frame dec;
    struct Frame enc;
};

/* These tests are from https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing#Encoding_examples */
struct test testSet[] =
{
    /*  1 */  { { 1,   "\x00"            },   { 3, "\x01\x01\x00"              } },
    /*  2 */  { { 2,   "\x00\x00"        },   { 4, "\x01\x01\x01\x00"          } },
    /*  3 */  { { 3,   "\x00\x11\x00"    },   { 5, "\x01\x02\x11\x01\x00"      } },
    /*  4 */  { { 4,   "\x11\x22\x00\x33"},   { 6, "\x03\x11\x22\x02\x33\x00"  } },
    /*  5 */  { { 4,   "\x11\x22\x33\x44"},   { 6, "\x05\x11\x22\x33\x44\x00"  } },
    /*  6 */  { { 4,   "\x11\x00\x00\x00"},   { 6, "\x02\x11\x01\x01\x01\x00"  } },
    /*  7 */  { { 254, "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe"}, {256, "\xff\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\x00" }},
    /*  8 */ {{ 255, "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe"}, {257, "\x01\xff\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\x00" }},
    /*  9 */ { {255, "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"}, {258, "\xff\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\x02\xff\x00"} },
    /* 10 */ { {255, "\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"}, {258, "\xff\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x01\x01\x00" }},
    /* 11 */ { {255, "\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00\x01"}, {257, "\xfe\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x02\x01\x00" }},
};

// ====================================================================================================

void _packetRxed ( struct Frame *p, void *param )

{
    struct test *t = ( struct test * )param;
    int k;

    for ( k = 0; ( ( k < p->len ) && ( p->d[k] == t->dec.d[k] ) ); k++ ) {}

    if ( k != p->len )
    {
        fprintf( stderr, "*********FAILED\nWanted:" );
        _printDigits( t->dec.len, t->dec.d );
        fprintf( stderr, "\nRecevd:" );
        _printDigits( p->len, p->d );
        fprintf( stderr, "\n" );
    }
    else
    {
        fprintf( stderr, "OK\n" );
    }
}
// ====================================================================================================

int main( int argc, void **argv )

{
    struct COBS *d = COBSInit( NULL );
    struct Frame o;
    int i, j, k;

    int oplen;

    if ( d )
    {
        fprintf( stderr, "COBS initialised to %llx\n", ( long long int )d );
    }
    else
    {
        fprintf( stderr, "*** ERR: COBS not created\n" );
    }

    fprintf( stderr, "Testing simple decode;\n" );

    for ( i = 0; i < sizeof( testSet ) / sizeof( struct test ); i++ )
    {
        fprintf( stderr, "%d: ", i + 1 );

        /* The +1 here is because we have a COBS_SYNC_CHAR on the end of each frame */
        if ( testSet[i].enc.len != COBSgetFrameExtent( testSet[i].enc.d, testSet[i].enc.len ) - testSet[i].enc.d + 1 )
        {
            fprintf( stderr, "Failed, packet length doesn't match (%d vs wanted %d\n", COBSgetFrameExtent( testSet[i].enc.d, testSet[i].enc.len ) - o.d, testSet[i].enc.len );
            continue;
        }

        if ( !COBSSimpleDecode( testSet[i].enc.d, testSet[i].enc.len, &o ) )
        {
            fprintf( stderr, "Failed, Packet did not decode\n" );
            continue;
        }

        for ( k = 0; ( ( k < o.len ) && ( o.d[k] == testSet[i].dec.d[k] ) ); k++ ) {}

        if ( k != o.len )
        {
            fprintf( stderr, "*********FAILED\nWanted:" );
            _printDigits( testSet[i].dec.len, testSet[i].dec.d );
            fprintf( stderr, "\nRecevd:" );
            _printDigits( o.len, o.d );
            fprintf( stderr, "\n" );
            continue;
        }

        fprintf( stderr, "OK\n" );
    }



    fprintf( stderr, "Testing pumped decode;\n" );

    for ( i = 0; i < sizeof( testSet ) / sizeof( struct test ); i++ )
    {
        fprintf( stderr, "%d: ", i + 1 );
        COBSPump( d, testSet[i].enc.d, testSet[i].enc.len, _packetRxed, &testSet[i] );
    }

    fprintf( stderr, "\nTesting encode;\n" );

    for ( int i = 0; i < sizeof( testSet ) / sizeof( struct test ); i++ )
    {
        fprintf( stderr, "%d: ", i + 1 );
        COBSEncode( testSet[i].dec.d, testSet[i].dec.len, &o );

        if ( o.len != COBSgetFrameExtent( o.d, o.len ) - o.d )
        {
            fprintf( stderr, "Static framelen assessment failed %d vs expected %d\n", o.len, COBSgetFrameExtent( o.d, o.len ) - o.d );
            continue;
        }

        if ( o.len != testSet[i].enc.len )
        {
            fprintf( stderr, "Length mismatch correct=%d vs actual=%d\n", testSet[i].enc.len, o.len );

            for ( int j = 0; j < o.len; j++ )
            {
                if ( o.d[j] != testSet[i].enc.d[j] )
                {
                    fprintf( stderr, "*********FAILED\nWanted:" );
                    _printDigits( testSet[i].enc.len, testSet[i].enc.d );
                    fprintf( stderr, "\nRecevd:" );
                    _printDigits( o.len, o.d );
                    fprintf( stderr, "\n" );
                    break;
                }
            }

        }
        else
        {
            fprintf( stderr, "OK\n" );
        }
    }
}
#endif

// ====================================================================================================
